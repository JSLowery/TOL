<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Thursday, May 21, 2015, 8:46 AM -->
<!-- MuClient version 4.79 -->

<!-- Plugin "TOL" generated by Plugin Wizard -->

<muclient>
<plugin
   name="TOL"
   author="Sonet"
   id="8065ca1ba19b529aee53ee44"
   language="Lua"
   save_state="y"
   date_written="2015-05-21 08:44:48"
   requires="4.79"
   version="1.171"
   >


<description trim="n">
<![CDATA[
-----------------------------------------------
-- Campaign specific commands
-----------------------------------------------
tcp | tcp <index>
      -- Without argument it goes to the first mob in the table, with it goes to that number
      -- Note this will also decide if it needs to be hunted or not all by its self
tcpo | tcpo <index>
      -- Withough argument goest to the first mob in the alternate table
tqs
      -- Quick Scan
km
      -- Sends the kill command for the last mob queued up by aknx
pt
      -- Prints the table of mobs and room numbers
pto
      -- Prints the other list of possible room cps
wm | wm <name>
      -- Quick where for a mob name or the last mob used with aknx
cpn <index> | <mob name>
      -- Hunt trick on the given index or mob name
kcpn
      -- turns off hunt script

-----------------------------------------------
-- Quest specific commands
-----------------------------------------------
tq | tq <index> - not case sensitive
      -- Without argument it goes to the most probable quest room, with it goes to that room
nq - not case sensitive
      -- Runs to the next quest room
rq | rq all
      -- Without argument it shows most likely rooms, with it it shows all possible rooms

-----------------------------------------------
-- Other commands
-----------------------------------------------
xrt1 <area>
      -- runs to areas
tkey "<mob>" "<keywords>"
      -- Stores special keywords for a mob.
cp | gq end
      -- clears the miniwindow
tlookup name <name> level <number> room <roomname> area <areaname>
      -- This will look up mobs in the db..
      -- Any order and as little as one of these can be used
      -- Experimental currently
Note:
  Adding a "Tstart" as in "mapper addnote Tstart" will tell TOL that this room is the begining of the area for this area
]]>
</description>
</plugin>
<!--  Get our standard constants -->

<include name="constants.lua"/>
  <timers>
  <timer
    name="execute_in_area_timer"
    script="execute_in_area_tick"
    enabled="n"
    second="0.25">
  </timer>
  <timer
    name="garbage_collection"
    script="collectgarbagenow"
    enabled="y"
    minute="5">
  </timer>
  </timers>
<!--  Aliases  -->

<aliases>
<alias
   enabled="y"
   match="^TOL debug on$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
  </alias>
   <alias
   enabled="y"
   match="^TOL debug off$"
   script="Toggle_Debug"
   regexp="y"
   sequence='100'
   >
 </alias>
 <alias
   match="^printVars$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printVars"
   regexp="y"
  >
  </alias>
  <alias
   match="^[t|T][Q|q]$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="qGoto"
   regexp="y"
  >
  </alias>
  <alias
     match="^[t|T][q|Q] (\d*)$"
     enabled="y"
     send_to="12"
     sequence="100"
     script="qGotoIndex"
     regexp="y"
  >
  </alias>
  <alias
    match="^[n|N][q|Q]$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qNext"
    regexp="y"
  >
  </alias>
  <alias
    match="^[r|R][q|Q]$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qRooms"
    regexp="y"
  >
  </alias>
  <alias
    match="^[r|R][q|Q] all$"
    enabled="y"
    send_to="12"
    sequence="100"
    script="qRoomsAll"
    regexp="y"
  >
  </alias>
  <alias
    enabled="y"
    match="^qTest$"
    script="qTest"
    regexp="y"
    sequence='100'>
  </alias>
  <alias match="^(?:TOL) help$"
    enabled="y"
    sequence="100"
    send_to="12"
    regexp="y"
    keep_evaluating="y"
  >
  <send>
    Note(getmemoryusage())
    ColourNote("MediumSeaGreen", "", GetPluginInfo (GetPluginID (), 3))
  </send>
  </alias>
  <alias
   match="^wm (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^wm$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="whereMob"
   regexp="y"
  >
  </alias>
      <alias
   match="^km$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="killMob"
   regexp="y"
  >
  </alias>
   <alias
   name="cp_check"
   script="cp_check"
   match="^(cp|campaign) (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to='12'
  >
  <send>Send('cp check')
  EnableTrigger('camp_item_start', 1)</send>
  </alias>
  <alias
   name="gq_check"
   script="gq_check"
   match="^gq (c|ch|che|chec|check)$"
   enabled="y"
   regexp="y"
   sequence="100"
   send_to="12"
  >
  <send> EnableTrigger('camp_item_start', 1)
  </send>
  </alias>
  <alias
   match="^tcp$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoNextMob"
   regexp="y"
  >
  </alias>
  <alias
   match='^tkey \"(.*?)\" \"(.*?)\"$'
   enabled="y"
   send_to="12"
   sequence="100"
   script="add_Keywords"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcpo$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="tcpohandler"
   regexp="y"
  >
  </alias>
  <alias
   match="^tcp (\d*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="gotoIndexMob"
   regexp="y"
  >
  </alias>

  <alias match="^xru?n?to?1 (.+)$"
    enabled="y"
    sequence="100"
    script="xrun_to1"
    regexp="y"
  >
  </alias>
  <alias match="^xma?p?p?e?r?1 move (?<roomid>[0-9]+) ?(?<speed>run|walk)?$"
  enabled="y"
  sequence="95"
  script="move_trigger"
  regexp="y"
  >
  </alias>

    <alias
   match="^pt$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable"
   regexp="y"
  >
  </alias>
   <alias
   match="^pto$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="printTable1"
   regexp="y"
  >
  </alias>
  <alias
   match="^(cp|campaign|gq|globalquest) end$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpgq_quit"
  >
  </alias>
<!-- the group that controlls the hunting aspects -->
<alias
   match="^cpn (.*?)$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^cpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="cpn_script"
  >
  </alias>
  <alias
   match="^kcpn$"
   enabled="y"
   send_to="12"
   sequence="100"
   regexp="y"
   script="hunt_off"
  >
  </alias>
   <alias
   match="^tqs$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="quickScan"
   regexp="y"
  >
  </alias>
  <alias
   match="^tlookup (.*)$"
   enabled="y"
   send_to="12"
   sequence="100"
   script="lookup"
   regexp="y"
  >
  </alias>
</aliases>
<triggers>
   <trigger
   enabled="n"
   match="^You still have to kill (?&lt;num&gt;[\d]*)?\s?\* (?&lt;name&gt;.*?) \((?&lt;location&gt;.*?)(?&lt;dead&gt; - Dead|)\)(|\.)$"
   name="campaign_item"
   script="campaign_item"
   sequence="100"
   regexp="y"
   group="campaigncheck"
   omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="n"
  match="^Note\: One or more target names in this campaign|gquest might be slightly scrambled\.$"
  name="camp_item_start"
  script="camp_item_start"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
   name="reset_cp_flag"
   custom_colour="7"
   match="CONGRATULATIONS! You have completed your campaign."
   script="reset_cp_flag"
   enabled="y"
   send_to="12"
   sequence="100"
  >
   </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^You get (.+) corpse of (.+)\.$"
   name="mobname"
   script="Add_To_Kill_Table"
   sequence="101"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^\[(?:\d+)\] Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight"
   script="mob_name"
   sequence="1"
  >
  </trigger>
  <trigger
   enabled="y"
   regexp="y"
   match="^Your (.*?) (.*?)(?:\!|\.) \[(?:\d+)\]$"
   name="mobnamefight1"
   script="mob_name"
   sequence="1"
  >
  </trigger>
   <trigger
   enabled="n"
   regexp="y"
   match="^Ayla gives you (.+) for the .+ corpse of (.+).$"
   name="saccorpse"
   script="mob_name"
   sequence="100"
  >
  </trigger>

  <trigger
  enabled="y"
  match="^(.*) tells you \'Good luck in your campaign\!\'$"
  name="camp_item"
  regexp='y'
  sequence='100'
  send_to='12'
  script="cp_check"
  omit_from_output="n"
  >
  <send>
  Send('cp check')
  EnableTrigger('camp_item_start', 1)
  timeStart()
  </send>
  </trigger>
<trigger
    name="mob_dead"
    custom_colour="11"
    match="Congratulations, that was one of your CAMPAIGN mobs!"
    enabled="y"
    sequence="100"
    send_to="12"
    script="delete_mob_from_table"
  >
    <send>mob_index=2

    </send>
  </trigger>
  <!-- Was (?P<mob>[^0-9]){30,30} (?P<room>.+) -->
  <trigger
    name="where_mob_trig"
    match= "^(?P<mob>[^0-9]{30,30}) (?P<room>.+)$"
    enabled="n"
    sequence="1"
    keep_evaluating="y"
    send_to="12"
    regexp="y"
    script="where_mob_trig"
  >
  </trigger>

  <!-- trigers for the hunting scripts -->
  <trigger
   group="HUNTING"
   match="^You seem unable to hunt that target for some reason\.$"
   name="CPFound"
   regexp="y"
   send_to="12"
   script="CPFound"
   sequence="100"
  >
 </trigger>

  <trigger
   expand_variables="y"
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) is (.*?)\?$"
   name="CPDoNext"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>

  <trigger
   group="HUNTING"
   match="^(.*?) is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
  </send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You are certain that .+ is .+ from here\.|You are almost certain that .+ is .+ from here\.|You are confident that .+ passed through here, heading .+\.|The trail of .+ is confusing, but you're reasonably sure .+ headed .+\.|There are traces of .+ having been here. Perhaps they lead .+\?|You have no idea what you\'re doing\, but maybe .+ is .+\?|You couldn\'t find a path to .+ from here\.|.+ is here\!$"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^No one in this area by the name \'(.*?)\'\.$"
   name="CPNotHere"
   regexp="y"
   send_to="12"
   sequence="100"
   script="not_here_script"
  >
  </trigger>
  <trigger
   group="HUNTING"
   match="^You couldn\'t find a path to (.*?) from here\.$"
   name="CPNoPath"
   regexp="y"
   script="incrementCounter"
   send_to="12"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="HUNTING"
   match="^You have no idea what you\'re doing\, but maybe (.*?) left (.*?)\?$"
   regexp="y"
   script="incrementCounter"
   sequence="100"
  >
  <send>
</send>
  </trigger>
  <trigger
   group="Questing"
   match="^You are in area \: (.+)"
   name="questTestArea"
   regexp="y"
   send_to="12"
   sequence="100"
  >

  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^(.*) can be found in the vicinity of (.*) which$"
   name="QuestInfo"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questRoom"
  >
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^You are on a quest to slay (.*)!$"
   name="QuestMob"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questMob"
  >
  </trigger>
  <trigger
   group="QuestI"
   enabled="y"
   match="^is in the general area of (.*).$"
   name="QuestInfoArea"
   regexp="y"
   send_to="12"
   sequence="100"
   script="questArea"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled='y'
   match="^(.*) tells you \'of (.*?)\.\'$"
   regexp="y"
   send_to="12"
   sequence="100"
  >
  <send>
  Send("q i")
  </send>
  </trigger>

  <trigger
   group="Quest"
   match="^QUEST\: You have almost completed your QUEST\!$"
   regexp="y"
   send_to="10"
   sequence="100"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled="y"
   regexp="y"
   match="(.*)(\!|\.)  \[QUEST\]$"
   send_to="12"
   sequence="100"
   script="quest_color"
  >
  </trigger>
  <trigger
   group="Quest"
   enabled="y"
   regexp="y"
   match="(.*)\[QUEST\]$"
   send_to="12"
   sequence="1"
   script="quest_color"
  >
  </trigger>



  <!-- Triggers for Global Quests   -->
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) - (.*) now started\.$"
  name="globalq_check"
  script="gq_check"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^Global Quest: Global quest # (?&lt;num&gt;\d*) for levels (\d*) to (\d*) has now started\.$"
  name="globalq_check1"
  script="gq_check"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You have now joined Global Quest # (.*)\. See \'help gquest\' for available commands\.$"
  name="globalq_start"
  script="gq_start"
  sequence='1'
  regexp="y"
  omit_from_output="n"
  >/
  </trigger>
  <trigger
  enabled="y"
  match="^Congratulations\, that was one of the GLOBAL QUEST mobs\!$"
  name="globalq_delete"
  script="delete_mob_from_table"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You were the first to complete this quest!|Global Quest: Global quest # (.*) (\(.*\))? is now over.|You are no longer part of Global Quest # (.*) and will be unable to rejoin.$"
  name="globalq_end"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  <trigger
  enabled="y"
  match="^You are not in a global quest.|You were the first to complete this quest!$"
  name="globalq_noton"
  script="gq_end"
  sequence='100'
  regexp="y"
  omit_from_output="n"
  >
  </trigger>
  </triggers>
  <timers>
  <timer name="grbg" enabled="y" minute="59" second="0.00" offset_second="0.00"    send_to="12"
>
  <send>
   DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)

   </send>

  </timer>
</timers>
<!--  Script  -->

<script>
<![CDATA[
dofile (GetPluginInfo (GetPluginID (), 20) .. "luapath.lua")

require "tprint"
require "KillTable"
require "pluginhelper"
require "serialize"
require "socket"
require "DistCalc"
require "MovementFuncs"
require "LookupFunc"
ThreadHolder= coroutine.running()
counter = tonumber(1)
counter1 = tonumber(1)

local Debug = false
currentRoom = {}
local char_status
local currentState
local tableNumHolder
local charname
local GQ_flag = false
local GQ_num
local started = false
mylevel = 0
mytier = 0
mobsleft= {}
cp_mobs= {}
local qmob

timestart= 0
timeend= 0
function hunt_off()
  Note('Turning off cpn script.')
  EnableTriggerGroup("HUNTING", false)
end
function getmemoryusage()
    collectgarbage('collect')
   return collectgarbage('count')
  end
function timeStart()
timestart = socket.gettime()
end
function timeEnd()
  timeend = socket.gettime()
  print ((timeend-timestart)/60)
end

function quickScan()
  Execute("scan " .. mobname)
end

function Toggle_Debug(name, line, wildcards)
  if string.find(line, "on") then
    Note ("Turning Debugging on")
    Debug = true
  else
    Note ("Turning Debugging off")
    Debug = false
  end
end

function cp_check( name, line, wildcards)
  EnableTrigger("campaign_item", true)
  mobsleft = {}
end -- cp_check

function gq_check( name, line, wildcards)
  DebugNote( "gq_check")
  DebugNote(wildcards)
  GQ_flag = true
  EnableTrigger('camp_item_start', 1)
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  if wildcards ~= nil and tonumber(GQ_num) == tonumber(wildcards.num) then
    EnableTrigger("campaign_item", true)
    DebugNote("Gquest started")
    GQ_num = tonumber(wildcards[1])
    DebugNote (GQ_num)
    Send("gq ch")
    mobsleft = {}

  elseif #wildcards <=1 then
    EnableTrigger("campaign_item", true)
    Send("gq ch")
    mobsleft = {}
  elseif tonumber(wildcards.num) ~= tonumber(GQ_num) then
    GQ_flag = false
    DebugNote("Shutting GQ_flag off")
    EnableTrigger('camp_item_start', 0)
  end
end -- gq_check

function gq_start(name, line, wildcards)
  DebugNote ("gq_start")
  --EnableTrigger("campaign_item", true)
  GQ_num = tonumber(wildcards[1])
  DebugNote (GQ_num)
  GQ_flag = true
  DebugNote("GQ_flag set to "..tostring(GQ_flag))
  mobsleft = {}
end

function cpgq_quit(name, line, wildcards)
  DebugNote(name)
  DebugNote(line)
  DebugNote(wildcards)
  if wildcards[1] == "gq" then
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
  end
  DebugNote("cpgq_quit")
  phelper:broadcast(4)
  cp_mobs = {}
  clearTable()
end

function gq_end(name, line, wildcards)
DebugNote(wildcards)
  if GQ_flag == false then return end
  if wildcards[1] == GQ_num then
    DebugNote("if block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(4)
    cp_mobs = {}
    clearTable()
  elseif #wildcards<1 then
    DebugNote("elseif block")
    GQ_flag = false
    DebugNote("GQ_flag set to "..tostring(GQ_flag))
    phelper:broadcast(3)
  end -- if
  DebugNote ("Gq is off now")
end

function add_Keywords(name, line, wildcards)
  if check_CPMobs_Table()<1 then
    print ("you don't have CPMobs table, you can't use this function, try installing the CPMobs plugin")
    return
  end
  query = string.format("UPDATE CPMobs SET keywords=%s WHERE name=%s;", fixsql(wildcards[2]), fixsql(wildcards[1]))
  querycheck = string.format("Select count(name) as count from CPMobs where name= %s;",fixsql(wildcards[1]))
  for a in dbkt:nrows(querycheck) do
    count = a.count
    if count<1 then
      print ("You have the name wrong, or it is not in the table, try again!")
      print ("You entered: " .. wildcards[1])
    end
  end
  if tonumber(count)<1 then
    return
  end
  rc= dbkt:exec(query)
  print ("Added ".. wildcards[2].. " to the mob entry for ".. wildcards[1])
  if rc ~= 0 then
    Note ( DatabaseError('dbkt'))
  end--if
end

function check_CPMobs_Table()
  local count = 0
  if dbkt:isopen() then
    checktable = "SELECT Count(name) as count FROM sqlite_master WHERE type='table' AND name='CPMobs';"
    for a in dbkt:nrows(checktable) do
      count = a.count
    end
    if count <1 then

        return 0
    end
    return 1
  else
    print('You either have not moved rooms or have not installed the CPMobs plugin. Try one of those first.')
  end
end

function camp_item_start()-- get your campaign items
  clearTable()

  EnableTrigger('campaign_item',false)
  EnableTrigger('camp_item_start',0)
  cp_mobs = {}
  cp_mobs= mobsleft
  if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")

  end--if
    FirstRun_cp_var= false
    check_dead()
    DebugNote(collectgarbage("count")*1024)
    collectgarbage("collect")
    DebugNote(collectgarbage("count")*1024)

end

function campaign_item (name, line, wildcards)-- the actual campaign item getter
  DebugNote("start cp_item mobsleft")
  DebugNote (wildcards)
  DebugNote("end cp_item mobsleft")
  name = wildcards.name
  mobdead = false
  location = wildcards.location
  num = tonumber(wildcards.num)
  if wildcards.dead ==  ' - Dead' then
    mobdead = true
  else
    mobdead = false
  end

  if not name or not location then
    print("error parsing line: ", line)
  else
    table.insert(mobsleft, {name=name, location=location, mobdead=mobdead, mobdead=mobdead,false, num = tonumber(num)})
  end
  end -- campaign_item

function delete_mob_from_table( )
  local found = false
  local tmp = {}
  local num
  if AutoUpdate_var == false and last_Enemy~= nil then
    for p,q in pairs (room_num_table) do
      num = tonumber(q[6]) or 1
      DebugNote (q)
      DebugNote(q[6])
      DebugNote ("Number of kills needed at time of delete_mob_from_table "..num)
      if string.lower(last_Enemy)== string.lower(q[2]) and num == 1 then
        table.remove(room_num_table,  p)
        table.remove(cp_mobs, p)
        found = true
        break
      elseif string.lower(last_Enemy)== string.lower(q[2]) then
        q[6] = q[6]-1
        cp_mobs[p].num = cp_mobs[p].num -1
        DebugNote(cp_mobs)
        DebugNote(cp_mobs[p][q])
        DebugNote ("number of mobs is ".. q[6])
        found = true
        break
      end--if
    end--for
    for p,q in pairs (room_num_table2) do
       if string.lower(last_Enemy)== string.lower(q[2]) then
        room_num_table2[p] = nil
        else
          table.insert(tmp, room_num_table2[p])
        end--if
    end--for
    room_num_table2 = tmp
    if found == false then
      DebugNote("Begin cp_mobs[mob_next_delete_value] check")
      DebugNote(num)
      DebugNote("End cp_mobs[mob_next_delete_value] check")
      table.remove(room_num_table,  mob_next_delete_value)
      table.remove(cp_mobs, mob_next_delete_value)
      DebugNote(GQ_flag)
      if GQ_flag == true then
        do_Execute_no_echo("gq check")
      else
        do_Execute_no_echo("cp check")
      end--if
    end--if
    mob_index= 1
  end--if
  check_diff()
  sortRoomCPByPath()
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
end

function delete_mob_from_table_index(val)
  if AutoUpdate_var == false and last_Enemy ~= nil then
  for p,q in pairs (room_num_table2) do
    num = tonumber(q[6]) or 1
     if string.lower(last_Enemy)== string.lower(q[2]) then
        table.remove(room_num_table2,  p)
      end--if
  end--for
  if room_num_table[val].num == 1 then
    table.remove(room_num_table, tonumber(val))
  else
    room_num_table[val][6] = room_num_table[val][6] -1
    cp_mobs[val].num = cp_mobs[val].num -1
  end
  DebugNote(collectgarbage("count")*1024)
  collectgarbage("collect")
  DebugNote(collectgarbage("count")*1024)
  mob_index= 1
  check_diff()
  end--if
end

function CPFound()
  if tonumber(count) >0 then
  Execute ("wm " .. count .. "." ..mobname)
  else
  Execute ("wm "  ..mobname)
  end
  EnableTriggerGroup("HUNTING", false)
end

function not_here_script()
  Execute("wm "..mobname)
  Note ("THIS IS NOT THE CORRECT AREA OR THE MOB IS DEAD")
  EnableTriggerGroup("HUNTING", false)

end

function quest_color()
  ColourNote ("white","blue","==================QUEST MOB HERE!!!!!!!!!!!!!!!!!!!!!!!=================")
end

function cpn_script (index, line, wildcards)
  -- print (index)
  -- print (line)
  local numcheck
  if wildcards ~= nil then
    numcheck = tonumber(wildcards[1])
  end
  DebugNote (index)
  DebugNote (type(index))
  DebugNote (numcheck)
    if  index ~= nil and type(index)== 'string'  then
        if #wildcards < 1 then
          index = mob_index

        elseif #wildcards <=1 and numcheck == nil then

          EnableTriggerGroup("HUNTING", true)
          reset_counter()
          mobname = wildcards[1]
          Execute ("hunt " .. mobname)
          --EnableTriggerGroup("HUNTING", false)
          return
        end
      if wildcards[1]== nil and mob_index ~= nil then
      else
      index = wildcards[1]
      end
    end --if
index = tonumber(index)
if room_num_table[index] == nil then
  print ("No cp_mob at that value")
  return
end--if
  EnableTriggerGroup("HUNTING", true)
  reset_counter()
  if room_num_table[index][1] ~= nil and cpn_is_room_type == false then
    getTable(index)
    Execute ("hunt " .. mobname)
  else
    Note("Either not on a cp or haven't checked it yet, or its a room type cp. Use hyperlink.")
    cpn_is_room_type= false
    EnableTriggerGroup("HUNTING", false)
  end
end

AutoUpdate_var = false
greedy = false
FirstRun_cp_var= true
-- This function is just for testing. It should never actually be used.
function printVars()
  tprint (cp_mobs)
--   Debug = true
--   DebugNote({1, 2})
--   Debug = false
--   --Clean_Kill_Table()
-- cp_mobs[1]={location= 'Stairwell'
-- ,mobdead= 'false',
-- name= 'King Breolerc',
-- clean = 'King Breolerc'}
-- cp_mobs[2]={location= 'The Conservatory'
-- ,mobdead= 'false',
-- name= 'a rabbit foot fern',
-- clean = 'a rabbit foot fern'}
-- cp_mobs[3]={location= 'North West Market Square'
-- ,mobdead= 'false',
-- name= 'Mino the Crazy',
-- clean = 'mino the crazy'}
-- cp_mobs[4]={location= 'High priest quarters'
-- ,mobdead= 'false',
-- name= 'an ancient ghost',
-- clean = 'an ancient ghost'}
local llthreads = require"llthreads"
print (package.cpath)
local thread_code = [[
temp= ''
-- local socket = require"socket"
--     -- print thread's parameter.
--     --dofile ("E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\luapath.lua")
-- -- temp = (package.cpath)
   local status, socket = pcall(require,"socket")
    local db = pcall(require,"lsqlite3")
--     -- if temp ~='' then
--     -- temp = (package.cpath) end
--     return status, socket
--   --   print("CHILD: received params:", ...)
    local tst=sqlite3.open('E:\\Users\\Jeremy\\Desktop\\r1802\\MUSHclient\\worlds\\plugins\\TOL\\KillTable.db')
--   --   local temp
    querycheck = "Select count(name) as count from CPMobs "
  for a in tst:nrows(querycheck) do
    temp =a.count
  end
--   --   -- print(tst)
--   --   -- return all thread's parameters back to the parent thread.
    return temp
]]


-- create detached child thread.
-- local thread = llthreads.new(thread_code, "number:", 12345, "nil:", nil, "bool:", true)
-- start non-joinable detached child thread.
-- assert(thread:start(true))
-- Use a detatched child thread when you don't care when the child finishes.
local function print_thread(...)
  local thread = llthreads.new([[ print("print_thread:", ...); ]], ...)
  -- start joinable thread
  assert(thread:start())
  return thread
end

local thread2 = print_thread("number:", 1234, "nil:", nil, "bool:", true)
print("thread2:join: results # = ", select('#', thread2:join()))
-- create child thread.
local thread = llthreads.new(thread_code, "test:", 1111)
-- start joinable child thread.
assert(thread:start())
-- Warning: If you don't call thread:join() on a joinable child thread, it will be called
-- by the garbage collector, which may cause random pauses/freeze of the parent thread.
-- luastmt = "gmcpdata = " .. thread:join()
--         assert (loadstring (luastmt or "")) ()
-- print(gmcpdata)
--print("thread:join: results # = ", select('3', thread:join()))
print("PARENT: child returned: ", thread:join())
--tprint (select('3', thread:join())
-- local socket = require"socket"
-- socket.sleep(2) -- give detached thread some time to run.
if myThread== nil  or coroutine.status (myThread) == "dead" then

        myThread = coroutine.create(buildRoomTable)
        AddTimer ("tickler", 0, 0, .1, "",
               timer_flag.Enabled + timer_flag.Replace,
               "tickle_it")
      end--if
 tprint(cp_mobs)
 tprint(room_num_table)

DebugNote(collectgarbage("count")*1024)
DebugNote("Mem Usage " .. collectgarbage("count"))
DebugNote(collectgarbage("count")*1024)
 phelper:broadcast(4)
 --test
-- collectgarbage("count")
end
-- end testing function
kill_info = {}
-- I hate to do it this way and will come up with a better solution... but for now
damage_verbs = {'misses ',
' tickles ',
' bruises ',
' scratches ',
' grazes ',
' nicks ',
' blasts',
' scars ',
' hits ',
' injures ',
' wounds ',
' mauls ',
' maims ',
' mangles ',
' mars ',
' massacres ',
' dismembers ',
' devastates ',
' disembowels ',
' lacerates ',
' LACERATES ',
' DECIMATES ',
' DEVASTATES ',
' ERADICATES ',
' OBLITERATES ',
' EXTIRPATES ',
' INCINERATES ',
' MUTILATES ',
' DISEMBOWELS ',
' MASSACRES ',
' DISMEMBERS ',
' RENDS ',
' meteorites ',
' glaciates ',
' nukes ',
' implodes ',
' asphyxiates ', --
' liquidates ', --
' fissures ', --
' exterminates ', --
' ravages ', --
' atomizes ', --
' sunders ', --
' tears into ', --
' destroys ', --
' pulverizes ', --
' demolishes ', --
' mutilates ', --
' incinerates ', --
' extirpates ', --
' obliterates ', --
' eradicates ', --
' annihilates ',-- nnih%
' evaporates ',-- vapor%
' ruptures ',-- upt%
' shatters ',-- hatter%
' slaughters ', -- laughters%
' vaporizes ',--vapor%
' wastes ',-- astes%
' shreds ',
' cremates ', -- remat%
' supernovas ',
' The charge slams into ',
' does UNSPEAKABLE things to ',
' does UNTHINKABLE things to ',
' does UNIMAGINABLE things to ',
' does UNBELIEVABLE things to ',
' %- BLASTS %- ',
' %-= DEMOLISHES =%- ',
' %*%* SHREDS %*%* ',
' %*%*%*%* DESTROYS %*%*%*%* ',
' %*%*%*%*%* PULVERIZES %*%*%*%*%* ',
' %-=%- VAPORIZES %-=%- ',
' <%-==%-> ATOMIZES <%-==%-> ',
' <%-:%-> ASPHYXIATES <%-:%-> ',
' <%-%*%-> RAVAGES <%-%*%-> ',
' <>%*<> FISSURES <>%*<> ',
' <%*><%*> LIQUIDATES <%*><%*> ',
' <%*><%*><%*> EVAPORATES <%*><%*><%*> ',
' <%-=%-> SUNDERS <%-=%-> ',
' <=%-=><=%-=> TEARS INTO <=%-=><=%-=> ',
' <%->%*<=> WASTES <=>%*<%-> ',
' <%-%+%-><%-%*%-> CREMATES <%-%*%-><%-%+%-> ',
' <%*><%*><%*><%*> ANNIHILATES <%*><%*><%*><%*> ',
' <%-%-%*%-%-><%-%-%*%-%-> IMPLODES <%-%-%*%-%-><%-%-%*%-%-> ',
' <%-><%-=%-><%-> EXTERMINATES <%-><%-=%-><%-> ',
' <%-==%-><%-==%-> SHATTERS <%-==%-><%-==%-> ',
' <%*><%-:%-><%*> SLAUGHTERS <%*><%-:%-><%*> ',
' <%-%*%-><%-><%-%*%-> RUPTURES <%-%*%-><%-><%-%*%-> ',
' <%-%*%-><%*><%-%*%-> NUKES <%-%*%-><%*><%-%*%-> ',
' %-<%[=%-%+%-=%]<:::<>:::> GLACIATES <:::<>:::>%[=%-%+%-=%]>%- ',
' <%-=%-><%-:%-%*%-:%-><%*%-%-%*> METEORITES <%*%-%-%*><%-:%-%*%-:%-><%-=%-> ',
' <%-:%-><%-:%-%*%-:%-><%-%*%-> SUPERNOVAS <%-%*%-><%-:%-%*%-:%-><%-:%-> ',
}
function mob_name(name,line,wildcards)

    if string.find(line, "%!") ~= nil then
      temp= string.sub(line, 10, string.find(line, "%!")-1 )
    elseif string.find(line, "%.") then
      temp= string.sub(line, 10, string.find(line, "%.")-1 )
    end--if
    DebugNote (temp)
    for i,v in pairs(damage_verbs) do
      o, p =string.find(temp, v)
      if p ~= nil then
        DebugNote (o.. " "..p.. " " .. v)
        DebugNote(temp)
        temp = string.sub(temp, p+1, #temp)
        last_Enemy = temp
        DebugNote(temp)
        return
      end--i
    end--for
    i = string.find(temp, "%A")
    while i  do
      temp= string.sub(temp, i+1, #temp )
      i=string.find(temp, "[%A][%s]")
      DebugNote (i)
    end -- while
    temp= string.sub(temp, 2, #temp )
    last_Enemy= temp
end
function Add_To_Kill_Table(name, line, wildcards)
  if greedy == false then
    return
  end--if
  kill_info.room_id= currentRoom.roomid
  kill_info.name= last_Enemy
  Add_Kill_Table(kill_info)
end

function check_dead ()
  check_diff()
  for p, q in ipairs(room_num_table) do
    if cp_mobs[p].mobdead ~= nil then
      if  q[2] == cp_mobs[p].name and cp_mobs[p].mobdead == true  then --used to be k.name and k.mobdead in case it doesn't work
        room_num_table[p][3] = true
      else
        room_num_table[p][3]= false
      end--if
    end
  end--for
end
-- TODO: Evaluate if this function is actually needed anymore.
function check_diff()
  if AutoUpdate_var== true then
    return
  end--if
    for p, q in pairs(room_num_table) do

      if cp_mobs[p]== nil then
         --print (p)
        --tprint (q)
        delete_mob_from_table_index(p)
        return
      end--if
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table > #cp_mobs  then
       delete_mob_from_table_index(p) -- not sure if this is working yet
       DebugNote ("If you see this message this was the function causing the stack overflow")
       elseif string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table < #cp_mobs then
      DebugNote('room <cp_mobs and names dont match')
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")
        end--if
        return
      end--if
      if string.lower(q[2])~= string.lower(cp_mobs[p].name) and #room_num_table == #cp_mobs then
       DebugNote('room ==cp_mobs and names dont match')
       DebugNote(q[2].. " ".. cp_mobs[p].name)
        if myThread== nil  or coroutine.status (myThread) == "dead" then
          myThread = coroutine.create(buildRoomTable)
          AddTimer ("tickler", 0, 0, .1, "",
             timer_flag.Enabled + timer_flag.Replace,
             "tickle_it")

        end--if
      end--if
    end--for
  mob_index= 1
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
end

myThread= nil
local level = 0
local mylevel = 0
local oldlevel = 0
-- New initialization checks - Kobus
got_room = false
got_char = false
didonce = false

function OnPluginBroadcast (msg, id, name, text)

    if (id == '3e7dedbe37e44942dd46d264') then
        if (text == "room.info") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","room.info")
            luastmt = "gmcpdata = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            currentRoom = {
              name = gmcpdata.name,
              roomid = gmcpdata.num,
              areaid = gmcpdata.zone
            }
						got_room = true -- Got the room data - Kobus
        end
        if (text == "char.status") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.status")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            char_status = gmcpdatacharstatus
            mylevel = tonumber(gmcpdatacharstatus.level)
        end
        if (text == "char.base") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdata = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            mytier = tonumber(gmcpdata.tier)
            got_char = true -- Got the char data - Kobus
        end
        if mylevel ~= oldlevel and didonce == true then -- We leveled?, rebuild CPMobs table
            print('level != oldlevel')
            CpMobsAbr(mylevel) -- Rebuild the CPMobs table - Kobus
        end

        if (text == "char.base") then
            res, gmcparg = CallPlugin("3e7dedbe37e44942dd46d264","gmcpval","char.base")
            luastmt = "gmcpdatacharstatus = " .. gmcparg
            assert (loadstring (luastmt or "")) ()
            char_base= gmcpdatacharstatus
        end
				if got_room and got_char and not didonce then didonce = true print("start") StartScript() end -- Got what we needed from GMCP, initialize the TOL script -- Kobus
    end
end

CPMobsLevelBound = nil
-- takes a level and makes a CPmobs table that is within 30 level of our current level
function CpMobsAbr(str)
    print('building CPMobsLevelBound')
  CPMobsLevelBound = nil
  levelAdj= 30
  levmin = tonumber(str)-levelAdj
  levmax = tonumber(str)+levelAdj
  query = string.format("select *, count(*) as timeskilled from CPMobs "..
    " where level < %s and level > %s "..
    " group by room_id order by  name, timeskilled desc", levmax, levmin)

  c = 0
  CPMobsLevelBound = {}
  for rows in dbkt:nrows(query) do
    c = c+1
    CPMobsLevelBound[c] = {
    name = rows.name,
    room_id = rows.room_id,
    room_name = rows.room_name,
    area_name = rows.area_name,
    level = rows.level,
    timeskilled = rows.timeskilled
  }
  end
print('Finished building CPMobsLevelBound')
	oldlevel = mylevel -- Won't rebuild until we level again - Kobus
end

function tickle_it ()

  -- if background task exists, and is suspended, resume it
  if myThread ~= nil and
     coroutine.status (myThread) == "suspended" then
    coroutine.resume (myThread)
  else
    EnableTimer ("tickler", false)  -- don't need timer now
  end -- if
end -- tickle_it

room_num_table = {}

function clearTable()
  room_num_table= {}
  room_num_table2= {}
end

function makeTable(room_num, name, bool, isInTable, area, num)-- stores all names and room numbers into a global table
  room_num_table[counter]= {room_num, name, bool, isInTable, area, tonumber(num)}
  counter= counter + 1
-- tprint(room_num_table)
-- print(counter)

end
function makeTable2(room_num, name, bool, inTable, area)-- stores all names and room numbers into a global table
  room_num_table2[counter1]= {room_num, name, bool, inTable, area}
  counter1= counter1 + 1


end
--TODO: Change both prints to actually be something worth looking at.
function printTable() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table ~= nil and #room_num_table>0 then
    ColourNote("Gray", "", "NUM  Mob name                             Dist   RoomId        Area")
    ColourNote("Gray", "", "------------------------------------------------------------------------");
    for i, row in pairs(cp_mobs) do
      print(string.format("%3d  %-35s  %-3s %-10s (%s) ", i, row.name,row.dist,room_num_table[i][1]  ,row.location))
    end
    ColourNote("Gray", "", "------------------------------------------------------------------------");
  DebugNote(cp_mobs)
  else
    print ("Nothing to print")
  end--if
end

function printTable1() -- prints the global table for names and room numbers, used for debugging or quick checking
 if room_num_table2 ~= nil and #room_num_table2>0 then
  tprint(room_num_table2)
  else
    print ("Nothing to print")
  end--if
end

curMob= ''
mobname= ''
word_count= tonumber(0)

function getTable(index) -- returns the first item in the table of room numbers, also makes a variable 'mobname' which is used for the autokill comand
    if room_num_table[index]== nil then
      return -1
    end
      local num =room_num_table[tonumber(index)][1]
      curMob= room_num_table[tonumber(index)][2]
    getName(index, 1)
    return num
end
-- Questioning why I am passing the num variable here... was this legacy?
function getName(index, num)
  local s= ''
  if cp_mobs== nil then
    print ("Use tcp before that command please")
    return
  end--if
  s = room_num_table[tonumber(index)][2] or curMob
 mobname = sanitizeName(s)
end

function sanitizeName(s)
local exit = 0
if s==nil then
  Note("s was nil")
  return
end
if check_CPMobs_Table()>0 then-- this needs to be reworked once all versions are unified. Aka when all versions have CPMobs support for Room CPs
  check_Keywords = string.format("SELECT keywords from CPMobs WHERE name= %s and keywords <> '';", fixsql(s))
  if dbkt:exec(check_Keywords) == 0 then
    DebugNote("Was not busy on database call")
    for keys in dbkt:nrows(check_Keywords) do
      DebugNote(keys)
      if keys.keywords ~= nil and keys.keywords ~= '' then
        mobname = keys.keywords
        exit = 1
      end
    end
  else
    DebugNote("The call in sanatize name to keywords was busy")
  end
  if exit == 1 then
    return mobname
  end
end
  local s2= {}
  s =string.gsub(s, "-", " ")
  s =string.gsub(s, "'", " ")
  s =string.gsub(s, "%@r", " ")
  for i in s:gmatch( "%a+") do
    word_count = tonumber(word_count) + 1
    s2[word_count]= i
    s2[word_count]= string.gsub(s2[word_count] , ",", " ")
  end -- for
  word_count= 0
  if (s2[1] == "a" or s2[1] == "A" or s2[1] == "An" or s2[1] == "the" or s2[1] == "The" or s2[1] == "an") and table.getn(s2) >1 then
    if table.getn(s2)>2
    then
      s2[2]= string.sub(s2[2], 0, 3)
      s2[3] = string.sub(s2[#s2],0, 3)
      mobname = s2[2].." "..s2[3]
      else
      mobname = s2[2]
    end -- if
  else
  if table.getn(s2)>1
  then
    s2[1]= string.sub(s2[1], 0, 3)
    s2[2] = string.sub(s2[#s2],0, 3)
    mobname = s2[1].." "..s2[2]
  else
    mobname = s2[1]
  end--if
  end--if
    return mobname
end

function buildRoomTable()-- This sends the table to get room_ids
--local time1 = socket.gettime()*1000
  if cp_mobs ==nil then
      cp_mobs = mobsleft
  end
  counter = tonumber(1)
  counter1 = tonumber(1)
  FirstRun_cp_var = false
  clearTable()
  local roomCPCheck = 0
  for i,v in ipairs (cp_mobs) do
    roomCPCheck = getRoomId(cp_mobs[i].name, i )
    -- if (i%3== 0)then
    --   coroutine.yield(myThread)
    -- end--if
  end
    coroutine.yield(myThread)
  for i,v in ipairs(room_num_table) do
    if (room_num_table[i][4]== false) then
      cp_mobs[i].intable = false
    else
      cp_mobs[i].intable = true
    end--if
  end --for
  DebugNote('==============================')
  sortRoomCPByPath()
  var.cp_mobs = serialize.save( "cp_mobs", cp_mobs )
  phelper:broadcast(1, var.cp_mobs)
end

local shortaname

function getRoomId(name, tableNum)-- Gets a roomId from campaign
local loc = cp_mobs[tableNum].location
dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  if dbA:isopen() then
    local query1 = "select rooms.uid as room, rooms.name as roomName, rooms.area as area, areas.name as areaName, 'room' as type "..
        " from rooms rooms, areas "..
        " where areas.uid = rooms.area and "..
        " rooms.name = %s "..
        " union "..
        " SELECT rooms.uid as room, rooms.name as roomName, areas.uid as area, areas.name as areaName, 'area' as type" ..
        " FROM areas, rooms " ..
        " WHERE areas.name = %s and "..
        "rooms.area = areas.uid "..
        " ORDER BY type ASC "
    sql_now= string.format(query1, fixsql(loc), fixsql(loc) )
    -- print(sql_now)
    local count_check= 0
    local hld = {}
    for rows in dbA:nrows(sql_now) do
    -- tprint(rows)
      table.insert(hld, rows)
    end -- for
    -- tprint(hld)
    if #hld == 0 then
        print('this cp will be weird because of unmapped rooms.. all entries are subject TOL has broken')
    end
    for g, rows in pairs(hld) do
      -- this whole thing needs reworked... its a mess right now..
      if rows.type== 'room' then
        -- print(name)
        getRoomIdRoomCP(name,name, tableNum)
        dbA:close()
        return 1
      else
        getRoomIdAreaCP(name, tableNum)
        dbA:close()
        return 0
      end--if
    end
  end--if
end
sublist={1,1}
--TODO: Evaluate if this needs to be here at all.
function testtime(name)

end

function getRoomIdAreaCP(name, tableNum)
    local nameHolder= nil
    local roomNumber= nil
    local roomTemp= nil
    local loc = cp_mobs[tableNum].location
    local dbKillT = dbkt --dbkt assigner
    local found = false
    local time1 = socket.gettime()
    local thisrooms = rooms
    local thisareas = areas
    local timeskilled = 0
    local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
        "from CPMobs "..
        "where name like %s and "..
        "area_name = %s "..
        "group by room_id, name "..
        "ORDER by timeskilled desc ", fixsql(name), fixsql(loc))
    if CPMobsLevelBound ~= nil then
        for i, p in pairs(CPMobsLevelBound) do
            if name == p.name and loc == p.area_name and timeskilled<p.timeskilled then
              nameHolder = name
              roomNumber = p.room_id
              timeskilled = p.timeskilled
              found = true
            end
        end
    end
    if found == false then
        DebugNote("in query block")
        for a in dbKillT:nrows(cpmobquery) do
         DebugNote(a)
            if found== false then
                DebugNote('the one I will use is: ')
                DebugNote (a)
                nameHolder = a.name
                roomNumber = a.room_id
                found = true
            end
        end
    end
    local count= 0
    if found == false then
        testtime(name)-- this gets called every mob in your cp list let me show you the flow
        sublist={}
        for i, p in pairs(mobktbl) do
            if p.name == name then
                table.insert(sublist, {p.name, p.room_id, p.timeskilled})
            end
        end
      DebugNote("\n In second block ".. name.."\n")
        for i,a in pairs(sublist) do
            count = count+1
            DebugNote(a)
            DebugNote("-----")
            nameHolder=a[1]
            roomTemp= tostring(a[2])
                if found == false then
                    if thisrooms[roomTemp] ~= nil then
                        if loc == thisareas[thisrooms[roomTemp].area].name and found == false then
                            DebugNote(a[1])
                            found = true
                            roomNumber = roomTemp
                        end
                        DebugNote("+++++")
                    end
                end
        end --for
    end --if
    if roomNumber ~= nil and nameHolder ~=nil then
        DebugNote ("check")
        --tprint (cp_mobs)
        DebugNote(cp_mobs[tableNum].num)
        DebugNote ("///check")
        makeTable(tonumber(roomNumber), nameHolder, cp_mobs[tableNum].mobdead, true, loc, cp_mobs[tableNum].num)
        mob_index= 1
    end--if
    if roomNumber == nil then
        DebugNote("here")
        makeTable(loc, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, false, loc, cp_mobs[tableNum].num)
        mob_index= 1
    end--if
end

function getRoomIdRoomCP(name, nameHolder, tableNum)-- TODO some bug here where it drops the last 2 things in list
    local loc = cp_mobs[tableNum].location
    local mob_table_name= ''
    local rows_counter= 1
    local rows_counter_check= 0
    local databasetest = dbA
    local databasekt = dbkt --dbkt assigner
    local make1 = makeTable
    local make2 = makeTable2
    local call = CallPlugin
    local DebugNote = DebugNote
    local findmob_table= {}
    local area_table= {}
    local strbld = string.format
    local room_num_table= room_num_table
    local room_num_table2= room_num_table2
    local tableNum = tonumber(tableNum)
    local levelAdj = 11
    local found = 0
    local areaName
    -- print(name)
    res, gmcparg = call("3e7dedbe37e44942dd46d264","gmcpval","char") --- We just want the gmcp.char section.
    luastmt = "gmcpdata = " .. gmcparg --- Convert the serialized string back into a lua table.
    assert (loadstring (luastmt or "")) ()
    level = tonumber(gmcpdata.status.level) -- uncomment for live
    if GQ_flag then levelAdj = 22 end
    --level = 70 -- for testing
    min_level = level - levelAdj
    max_level = level + levelAdj
    if CPMobsLevelBound ~= nil then
        for i, p in pairs(CPMobsLevelBound) do

            if name == p.name and loc == p.room_name then
                -- print(tostring(loc == p.room_name))
                -- print(name)
                -- print(loc)
                -- tprint(p)
                make1(p.room_id, name, cp_mobs[tableNum].mobdead, true, p.area_name, cp_mobs[tableNum].num)
                return
            end
        end
    end
    if (min_level<0)then min_level=0 end
        local queryCount = strbld("select COUNT(*) as counter"..
          " from rooms, areas"..
          " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
        local query1 = strbld("select rooms.uid as roomuid,"..
          " areas.name as areaName,"..
          " rooms.name as roomName"..
          " from rooms rooms, areas"..
          " where areas.uid = rooms.area and rooms.name = %s",fixsql(cp_mobs[tableNum].location))
        local  cpmobquery = string.format("select room_id, area_name, name, COUNT(*) as timeskilled "..
            "from CPMobs "..
            "where name like %s and "..
            "room_name = %s"..
            "group by room_id, name "..
            "ORDER by timeskilled asc ", fixsql(name), fixsql(loc))

        for rows in databasekt:nrows(cpmobquery) do
            -- print("found in cpmobsquery")
           -- tprint(rows)
            roomNumber = rows.room_id
            areaName = rows.area_name
            found = 1
        end
        if found == 1 then
            found = 0
            DebugNote("found it in the cp_mobs table 001")
            make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, areaName, cp_mobs[tableNum].num)
            return
        end
        for rows in databasetest:nrows(queryCount) do
            rows_counter = rows.counter
        end--for
        for rows in databasetest:nrows(query1) do
            rows_counter_check = rows_counter_check+1
            area_table[rows_counter_check] = rows
        end--for
        local area_table_size = #area_table
        for z=1, area_table_size do
            roomNumber= tonumber(area_table[z].roomuid)
            if areaLevel[area_table[z].areaName].minLevel > max_level or areaLevel[area_table[z].areaName].maxLevel<min_level then -------- testing with and was or
                rows_counter= rows_counter-1
                rows_counter_check = rows_counter_check-1
            else
                local foundone_room_table2 = false
                local foundone_room_table = false
                if room_num_table ~= nil and #room_num_table >0 then
                   for p= 1, #room_num_table do
                       if (string.lower(room_num_table[p][2]) == string.lower(nameHolder) or room_num_table[p][1]== area_table[z].uid)
                        and tableNum== tableNumHolder then foundone_room_table= true  end--if-- cp_mobs[tableNum].name
                    end--for
                end--if
                if #room_num_table2 > 0 and room_num_table2 ~= nil then
                    for i= 1, #room_num_table2 do
                        if area_table[z].areaName == room_num_table2[i][5] or room_num_table2[i][1]== area_table[z].roomuid  then-- see if the first condition needs and tableNum == tableNumHolder

                            foundone_room_table2 = true
                            break
                        else
                            foundone_room_table2 = false
                        end--if
                    end--for
                end--if
                if not foundone_room_table then
                    make1(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                    tableNumHolder= tonumber(tableNum)
                    mob_index= 1
                elseif not foundone_room_table2 then
                    make2(roomNumber, cp_mobs[tableNum].name, cp_mobs[tableNum].mobdead, true, area_table[z].areaName, cp_mobs[tableNum].num)
                    mob_index= 1
                end--if
        end--for
    end--if
    tableNumHolder= tonumber(tableNum)
    mob_index= 1
    -- print(name)
    -- print('nothing')
end
room_not_in_database = {}


function sortRoomCPByPath()
  local x
  local room = -1
  dist_tbl = {}
  DebugNote('==============================')
  DebugNote(currentRoom.roomid)
  for i, p in ipairs(room_num_table) do
    DebugNote(i)
    DebugNote(p)
    x, dep = findpath(currentRoom.roomid,p[1])
    DebugNote('Depth:')
    DebugNote (dep)
    if dep ~= nil then
      table.insert(dist_tbl, { i, dep })
    else
      table.insert(dist_tbl, {i, 501})
    end--if
  end
  local keys = {}
  local b = {}
  local q = {}
  for k in pairs(dist_tbl) do table.insert(keys, k) end
  DebugNote('keys')
  DebugNote(keys)
  table.sort(keys, function(a, b) return dist_tbl[a][2] < dist_tbl[b][2] end)
  for _, k in ipairs(keys) do
    -- DebugNote('_ then k')
    -- DebugNote(_)
    -- DebugNote(k)
    -- DebugNote(k)
    -- DebugNote(dist_tbl[k][1])
    -- DebugNote(dist_tbl[k][2])
    cp_mobs[k].dist = dist_tbl[k][2]
    table.insert(b, cp_mobs[k])
    table.insert(q, room_num_table[k])
  end
  room_num_table = q
  cp_mobs = b

end

mob_index= tonumber(1)
mob_next_delete_value= nil

function do_Execute_no_echo(command)
  local original_echo_setting = GetOption("display_my_input")
  SetOption("display_my_input", 0)
  Execute(command)
  SetOption("display_my_input", original_echo_setting)
end

function gotoNextMob()-- This will goto the next mob, use with tcp
  if cp_mobs == nil then
    print ('Nothing to go to!')
    return
  end
  if mob_index == nil then
    mob_index=1
  end--if
  if room_num_table == nil or #room_num_table<1 then
    return
  end--if
  if room_num_table[1][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_dead()
  if room_num_table[1][3] == false then
    if hunt_type(0, 0) == 1 then
      return
    end--if

    Execute('xmapper1 move '..  getTable(mob_index))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    Send("sca ".. mobname)
  else
    if hunt_type(0, 1) == 1 then
      return
    end--if
    Execute('xmapper1 move '..  getTable(mob_index+1))
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index+1)
    mob_next_delete_value= mob_index+1
    Send("sca ".. mobname)
  end--if
end

function gotoIndexMob(name, line, wildcards)-- This will goto the next mob, use with tcp

  wild= tonumber(wildcards[1])
  if wild == nil then return end
  if cp_mobs == nil then
    print("Nothing to goto.")
    return
  end
  if tonumber(wildcards[1])<0 or tonumber(wildcards[1])> #room_num_table then
    return
  end
  if room_num_table == nil then
    return
  end--if
    if room_num_table[wild][1] == -1 then
    print ("Try tcpo or manually finding this mob.. use pto to check the other table")
    return
  end--if
  check_diff()
  check_dead()
    if hunt_type(wild, 0) == 1 then
      return
    end--if
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wild)
    mob_next_delete_value= wild
    Execute('xmapper1 move '..  getTable(tonumber(wildcards[1])))
    Send("sca ".. mobname)
end

function tcpohandler(name, line, wildcards)
  if wildcards[1] ~= nil then
    if room_num_table2 == nil or tonumber(wildcards[1])>#room_num_table2 then
     return
    end--if
  end--if

  if #wildcards>=1 then
     mobname = sanitizeName(room_num_table2[tonumber(wildcards[1])][2])
    Execute ('xmapper1 move '.. room_num_table2[tonumber(wildcards[1])][1])
    DebugNote("Entry for mob_next_delete_value")
    DebugNote(wildcards[1])
    mob_next_delete_value= wildcards[1]
    Send("sca ".. mobname)
  else
    mobname = sanitizeName(room_num_table2[1][2])
    Execute ('xmapper1 move '.. room_num_table2[1][1])
    mob_next_delete_value= 1
    Send("sca ".. mobname)
  end--if
end

function hunt_type (num, mob_id)
  if mob_index == 0 then
    local mob_index = 1
  else
    local mob_index = 2
  end--if
  if num ~= 0 then
    if type(room_num_table[tonumber(num)][1])== 'string' then -- If An index query and room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(num)
      mob_next_delete_value= tonumber(num)
      holder= getTable(num)
      if ((string.find(string.lower(room_num_table[num][1]), currentRoom.areaid))) then
        print('well this is awkward you are already in the correct area')
      else
        Execute('xrunto1 '..room_num_table[num][1])
      end--if
      cpn_script(tonumber(num))

      return 1
    end--if
  else
    if type(room_num_table[mob_index][1])== 'string' then-- if NOT an indexed query and a room type
      DebugNote("Entry for mob_next_delete_value")
    DebugNote(mob_index)
    mob_next_delete_value= mob_index
    holder= getTable(mob_index)
    if (( string.find(string.lower(room_num_table[mob_index][1]), currentRoom.areaid))) then
      print('well this is awkward you are in the correct area')
    else
      Execute('xrunto1 '..room_num_table[mob_index][1])
    end--if
    cpn_script(mob_index)

      return 1
    end--if
  end--if
end

where_mob= ''

function whereMob(name, line, wildcards)
  where_mob= wildcards[1]
  if where_mob==nil then
     if mobname ~= nil then
      EnableTrigger('where_mob_trig', true)
      Execute('where '.. mobname)

      DoAfterSpecial(2, "EnableTrigger('where_mob_trig', false)", 12)
    else
      print ("Need to use tcp or tcp <index> first")
      return
    end --if
  else
    EnableTrigger('where_mob_trig', true)
    Execute('where '.. where_mob)
    DoAfterSpecial(1, "EnableTrigger('where_mob_trig', false)", 12)
    where_mob = string.gsub(where_mob,"%d+%.","")
    mobname =  where_mob
  end--if
end

local where_black_list = {"Your magic is blessed with",
"You feel less righteous as the",
"You now possess magical powers",
"You feel gills growing on your",
"You now detect the presence of"}
function where_mob_trig(name, line, wildcards)
  for i,p in ipairs(where_black_list) do
    if (string.find( wildcards[0], p) ~= nil) then
      return
    end--if
  end--for
    wildcards[1], x = string.gsub(wildcards[1],"%.","")
  bool = 0
  for word in mobname:gmatch("%w+") do
  if (string.find( string.lower(wildcards[1]), string.lower(word)) ~= nil) then
    bool =1
  end--if

  end -- for
  if bool == 1 then
    Execute('mapper area '.. '"'..wildcards[2]..'"')
    Execute('mapper next')
    EnableTrigger('where_mob_trig', false)
  end--if
end

function killMob()
  if mobname ~= nil then
    Execute("kill ".. mobname)
  else
    print ("Need to use aknx or aknx <index> first")
  end --if
end

function fixsql (s)
   if s then
      return "'" .. (string.gsub (s, "'", "''")) .. "'" -- replace single quotes with two lots of single quotes
   else
      return "NULL"
   end -- if
end -- fixsql

areaLevel= {}

-- In case of a mob not in the db then these will get used

count = 1
function incrementCounter()
count = count + 1
Execute("hunt ".. count..".".. mobname)
end

function reset_counter()
 count=1
end
CPMobs= {}
CPMobs1= {}
CPMobsIndex= 1
vnum_holder= 0
function reset_index()
 CPMobsIndex = 1
 CPMobs1= {}
end

cpn_is_room_type= false
cpn_is_room_type_table = {}
cpnrtt = 1



function hunt_from_link( area)
  DebugNote (area)
  Execute("xrunto1 ".. area)
  Execute ("hunt " .. mobname)
end

dbA= nil
dbkt= nil
rooms = {1, 1}
areas = {}
mobktbl = {}
function StartScript()
  print("here")
  do_Execute_no_echo('map')

  do_Execute_no_echo("cp check")


  db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')
  query= "select keyword, name, afrom, ato, alock from areas"
  rc =db:exec(query)
  if rc ~= 0 then
    db:close()
    os.remove(GetInfo (66) .."\\logs\\aardinfo.db")
    os.rename(GetPluginInfo (GetPluginID (), 20) .."aardinfo.db", GetInfo (66) .."\\logs\\aardinfo.db")
    db=sqlite3.open(GetInfo (66) ..'\\logs\\aardinfo.db')

  end
  local v =tonumber(0)
  for a in db:nrows(query) do
    areaLevel[a.name]= {}
    areaLevel[a.name].keyword= a.keyword
    areaLevel[a.name].name = a.name
    areaLevel[a.name].minLevel= a.afrom
    areaLevel[a.name].maxLevel= a.ato
    areaLevel[a.name].lock = a.alock or ''
    v = v +1
  end-- for
  v = 0
  db:close()
  dbA=sqlite3.open(GetInfo (66) ..'Aardwolf.db')
  print (GetPluginInfo (GetPluginID (), 20))
  dbkt=sqlite3.open(GetPluginInfo (GetPluginID (), 20) .. 'KillTable.db')
  dbkt:busy_handler(myHandler)
  qry= "select * from rooms where uid not like '*' and uid not like '**' order by uid"
  qry2 = "select * from areas"
  qry3 = "select *, count(*) as timeskilled from mobkills group by room_id order by name, timeskilled desc"
  c= 0
  CpMobsAbr(mylevel)
  rooms = {}

  for row in dbA:nrows(qry) do

    rooms[row.uid]= {}
      c = c+1

    rooms[row.uid] = {
    name = row.name,
    area = row.area,
    terrain = row.terrain,
    info = row.info,
     noportal = row.noportal,
     norecall = row.norecall,
     ignore_exits_mismatch = (row.ignore_exits_mismatch == 1),
     exits = {},
     exit_locks = {}
    }

  end
  for row in dbA:nrows(qry2) do
    areas[row.uid] = {
      name = row.name
  }
  end
 -- c = 0
  for row in dbkt:nrows(qry3) do
   c = c+1
    mobktbl[c] = {
      name = row.name,
      room_id =row.room_id,
      timeskilled = row.timeskilled
  }
  end -- end of for loop? lol, whoops ok  lets do it
      for i,v in pairs(rooms) do
        c =c +1
      end
  rc =dbkt:exec([[SELECT name, room_id FROM mobkills ]])
  if rc~= 0 then
    init()
    print ('making table')
  end--if
  if not IsPluginInstalled("0961770926b613688a1c5458") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "cp_mobTableFiller.xml")
  end
  if not IsPluginInstalled("eee3a98a021c1bee534ef09f") then
    LoadPlugin(GetPluginInfo (GetPluginID (), 20) .. "TOLminwin.xml")
  end
  dbA:close()
end

function OnPluginInstall()
	-- Connected? GMCPHandler Enabled? Not initialized yet? Request the GMCP for initialization -Kobus
	if IsConnected() and GetPluginInfo("3e7dedbe37e44942dd46d264",17) and not didonce then
		Execute("sendgmcp request room")
		Execute("sendgmcp request char")
	end
end
function myHandler(udata, retries)
   DebugNote("BUSY!")
   return true
end
function OnPluginClose ()
    --dbA:close()
    if dbkt ~= nil and dbkt:isopen() then dbkt:close() end
end

function reset_cp_flag( )
  timeEnd()
  FirstRun_cp_var= true
end

function collectgarbagenow()
 --Note( collectgarbage("count")*1024)
  collectgarbage("collect")
  --Note( collectgarbage("count")*1024)
end

function DebugNote( msg )
  if not Debug then return end
    if type(msg)== 'table' then
      tprint(msg)
    else
      Note (msg)
    end

end


  -----------------------------------------------------------
  -- Questing
  -----------------------------------------------------------
  local CQuestHandler = require "questhandle"
  local questHandler = CQuestHandler.create()

  -- Questing Triggers
  function QuestInfoHandle(name, line, wildcards)
	questHandler:setMob(wildcards[1])
    questHandler:setRoom(wildcards[2])
  end

  function QuestInfoHandleArea(name, line, wildcards)
    questHandler:setArea(wildcards[1])
  end

  function questMob(name, line, wildcards)
    questHandler:setMob(wildcards[1])
  end

  function questRoom(name, line, wildcards)
    questHandler:setRoom(wildcards[2])
  end

  function questArea(name, line, wildcards)
    questHandler:setArea(wildcards[1])
  end

  function qGoto()
    mobname = sanitizeName(questHandler.mob)
    questHandler:gotoFirst()
  end

  function qGotoIndex(name, line, wildcards)
    local idx = tonumber(wildcards[1])
    if idx == nil then return end

    mobname = sanitizeName(questHandler.mob)
    questHandler:gotoIndex(idx)
  end

  function qNext()
    mobname = sanitizeName(questHandler.mob)
	questHandler:gotoNext()
  end

  function qRooms()
    questHandler:showRooms()
  end

  function qRoomsAll()
    questHandler:showRooms(true)
  end

  function qTest()
    questHandler:setMob("the Liavango Despot")
    questHandler:setRoom("Home of the Despot")
    questHandler:setArea("The Darkside of the Fractured Lands")
  end

]]>
</script>


</muclient>
